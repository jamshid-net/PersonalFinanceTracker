//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IFin_transactionApiService {
    createTransaction(requestModel: FinanceTransactionRequestModel): Observable<ResponseDataOfFinanceTransactionResponseModel>;
    updateTransaction(requestModel: FinanceTransactionRequestModel): Observable<ResponseDataOfFinanceTransactionResponseModel>;
    deleteTransaction(id: number): Observable<ResponseDataOfBoolean>;
    getTransactionById(id: number): Observable<FinanceTransactionResponseModel>;
    getTransactions(request: FilterRequest): Observable<ResponseDataOfPageListOfFinanceMiniTransactionResponseModel>;
    getCurrentMonthSummary(): Observable<ResponseDataOfMonthlySummaryResponseModel>;
    getMonthlyTrends(months: number): Observable<ResponseDataOfListOfMonthlyTrendResponseModel>;
}

@Injectable({
    providedIn: 'root'
})
export class Fin_transactionApiService implements IFin_transactionApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    createTransaction(requestModel: FinanceTransactionRequestModel): Observable<ResponseDataOfFinanceTransactionResponseModel> {
        let url_ = this.baseUrl + "/api/web/FinTransaction/CreateTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTransaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfFinanceTransactionResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfFinanceTransactionResponseModel>;
        }));
    }

    protected processCreateTransaction(response: HttpResponseBase): Observable<ResponseDataOfFinanceTransactionResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfFinanceTransactionResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateTransaction(requestModel: FinanceTransactionRequestModel): Observable<ResponseDataOfFinanceTransactionResponseModel> {
        let url_ = this.baseUrl + "/api/web/FinTransaction/UpdateTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfFinanceTransactionResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfFinanceTransactionResponseModel>;
        }));
    }

    protected processUpdateTransaction(response: HttpResponseBase): Observable<ResponseDataOfFinanceTransactionResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfFinanceTransactionResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteTransaction(id: number): Observable<ResponseDataOfBoolean> {
        let url_ = this.baseUrl + "/api/web/FinTransaction/DeleteTransaction?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTransaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfBoolean>;
        }));
    }

    protected processDeleteTransaction(response: HttpResponseBase): Observable<ResponseDataOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTransactionById(id: number): Observable<FinanceTransactionResponseModel> {
        let url_ = this.baseUrl + "/api/web/FinTransaction/GetTransactionById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FinanceTransactionResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FinanceTransactionResponseModel>;
        }));
    }

    protected processGetTransactionById(response: HttpResponseBase): Observable<FinanceTransactionResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FinanceTransactionResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTransactions(request: FilterRequest): Observable<ResponseDataOfPageListOfFinanceMiniTransactionResponseModel> {
        let url_ = this.baseUrl + "/api/web/FinTransaction/GetTransactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfPageListOfFinanceMiniTransactionResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfPageListOfFinanceMiniTransactionResponseModel>;
        }));
    }

    protected processGetTransactions(response: HttpResponseBase): Observable<ResponseDataOfPageListOfFinanceMiniTransactionResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfPageListOfFinanceMiniTransactionResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCurrentMonthSummary(): Observable<ResponseDataOfMonthlySummaryResponseModel> {
        let url_ = this.baseUrl + "/api/web/FinTransaction/GetCurrentMonthSummary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentMonthSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentMonthSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfMonthlySummaryResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfMonthlySummaryResponseModel>;
        }));
    }

    protected processGetCurrentMonthSummary(response: HttpResponseBase): Observable<ResponseDataOfMonthlySummaryResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfMonthlySummaryResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMonthlyTrends(months: number): Observable<ResponseDataOfListOfMonthlyTrendResponseModel> {
        let url_ = this.baseUrl + "/api/web/FinTransaction/GetMonthlyTrends?";
        if (months === undefined || months === null)
            throw new Error("The parameter 'months' must be defined and cannot be null.");
        else
            url_ += "months=" + encodeURIComponent("" + months) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMonthlyTrends(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMonthlyTrends(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfListOfMonthlyTrendResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfListOfMonthlyTrendResponseModel>;
        }));
    }

    protected processGetMonthlyTrends(response: HttpResponseBase): Observable<ResponseDataOfListOfMonthlyTrendResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfListOfMonthlyTrendResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICategoryApiService {
    createCategory(requestModel: CategoryRequestModel): Observable<ResponseDataOfCategoryResponseModel>;
    updateCategory(requestModel: CategoryRequestModel): Observable<ResponseDataOfCategoryResponseModel>;
    deleteCategory(id: number): Observable<ResponseDataOfBoolean>;
    getCategoryById(id: number): Observable<ResponseDataOfCategoryResponseModel>;
    getCategories(filter: FilterRequest): Observable<ResponseDataOfPageListOfCategoryResponseModel>;
    getTopExpenseCategories(top: number): Observable<ResponseDataOfListOfTopCategoryExpenseResponseModel>;
}

@Injectable({
    providedIn: 'root'
})
export class CategoryApiService implements ICategoryApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    createCategory(requestModel: CategoryRequestModel): Observable<ResponseDataOfCategoryResponseModel> {
        let url_ = this.baseUrl + "/api/web/Category/CreateCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfCategoryResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfCategoryResponseModel>;
        }));
    }

    protected processCreateCategory(response: HttpResponseBase): Observable<ResponseDataOfCategoryResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfCategoryResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateCategory(requestModel: CategoryRequestModel): Observable<ResponseDataOfCategoryResponseModel> {
        let url_ = this.baseUrl + "/api/web/Category/UpdateCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfCategoryResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfCategoryResponseModel>;
        }));
    }

    protected processUpdateCategory(response: HttpResponseBase): Observable<ResponseDataOfCategoryResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfCategoryResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteCategory(id: number): Observable<ResponseDataOfBoolean> {
        let url_ = this.baseUrl + "/api/web/Category/DeleteCategory?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfBoolean>;
        }));
    }

    protected processDeleteCategory(response: HttpResponseBase): Observable<ResponseDataOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCategoryById(id: number): Observable<ResponseDataOfCategoryResponseModel> {
        let url_ = this.baseUrl + "/api/web/Category/GetCategoryById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfCategoryResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfCategoryResponseModel>;
        }));
    }

    protected processGetCategoryById(response: HttpResponseBase): Observable<ResponseDataOfCategoryResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfCategoryResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCategories(filter: FilterRequest): Observable<ResponseDataOfPageListOfCategoryResponseModel> {
        let url_ = this.baseUrl + "/api/web/Category/GetCategories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfPageListOfCategoryResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfPageListOfCategoryResponseModel>;
        }));
    }

    protected processGetCategories(response: HttpResponseBase): Observable<ResponseDataOfPageListOfCategoryResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfPageListOfCategoryResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTopExpenseCategories(top: number): Observable<ResponseDataOfListOfTopCategoryExpenseResponseModel> {
        let url_ = this.baseUrl + "/api/web/Category/GetTopExpenseCategories?";
        if (top === undefined || top === null)
            throw new Error("The parameter 'top' must be defined and cannot be null.");
        else
            url_ += "top=" + encodeURIComponent("" + top) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopExpenseCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopExpenseCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfListOfTopCategoryExpenseResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfListOfTopCategoryExpenseResponseModel>;
        }));
    }

    protected processGetTopExpenseCategories(response: HttpResponseBase): Observable<ResponseDataOfListOfTopCategoryExpenseResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfListOfTopCategoryExpenseResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAuth_userApiService {
    login(requestModel: LoginRequestModel): Observable<ResponseDataOfTokenResponseModel>;
    refreshToken(refreshToken: string): Observable<ResponseDataOfTokenResponseModel>;
    logout(refreshToken: string): Observable<ResponseDataOfBoolean>;
    register(requestModel: RegisterUserRequestModel): Observable<ResponseDataOfTokenResponseModel>;
}

@Injectable({
    providedIn: 'root'
})
export class Auth_userApiService implements IAuth_userApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    login(requestModel: LoginRequestModel): Observable<ResponseDataOfTokenResponseModel> {
        let url_ = this.baseUrl + "/api/web/AuthUser/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfTokenResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfTokenResponseModel>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<ResponseDataOfTokenResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfTokenResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refreshToken(refreshToken: string): Observable<ResponseDataOfTokenResponseModel> {
        let url_ = this.baseUrl + "/api/web/AuthUser/RefreshToken?";
        if (refreshToken === undefined || refreshToken === null)
            throw new Error("The parameter 'refreshToken' must be defined and cannot be null.");
        else
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfTokenResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfTokenResponseModel>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<ResponseDataOfTokenResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfTokenResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    logout(refreshToken: string): Observable<ResponseDataOfBoolean> {
        let url_ = this.baseUrl + "/api/web/AuthUser/Logout?";
        if (refreshToken === undefined || refreshToken === null)
            throw new Error("The parameter 'refreshToken' must be defined and cannot be null.");
        else
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfBoolean>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<ResponseDataOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    register(requestModel: RegisterUserRequestModel): Observable<ResponseDataOfTokenResponseModel> {
        let url_ = this.baseUrl + "/api/web/AuthUser/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfTokenResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfTokenResponseModel>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<ResponseDataOfTokenResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfTokenResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IManage_userApiService {
    getAllUsers(filterRequest: FilterRequest): Observable<ResponseDataOfPageListOfUserResponseModel>;
}

@Injectable({
    providedIn: 'root'
})
export class Manage_userApiService implements IManage_userApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllUsers(filterRequest: FilterRequest): Observable<ResponseDataOfPageListOfUserResponseModel> {
        let url_ = this.baseUrl + "/api/web/ManageUser/GetAllUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfPageListOfUserResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfPageListOfUserResponseModel>;
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<ResponseDataOfPageListOfUserResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfPageListOfUserResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRolesApiService {
    createRole(requestModel: RoleRequestModel): Observable<ResponseDataOfRoleDetailsResponseModel>;
    updateRole(requestModel: RoleRequestModel): Observable<ResponseDataOfRoleDetailsResponseModel>;
    getRoleDetails(roleId: number): Observable<ResponseDataOfRoleDetailsResponseModel>;
    getRoles(filterRequest: FilterRequest): Observable<ResponseDataOfPageListOfRoleResponseModel>;
}

@Injectable({
    providedIn: 'root'
})
export class RolesApiService implements IRolesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    createRole(requestModel: RoleRequestModel): Observable<ResponseDataOfRoleDetailsResponseModel> {
        let url_ = this.baseUrl + "/api/web/Roles/CreateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfRoleDetailsResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfRoleDetailsResponseModel>;
        }));
    }

    protected processCreateRole(response: HttpResponseBase): Observable<ResponseDataOfRoleDetailsResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfRoleDetailsResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateRole(requestModel: RoleRequestModel): Observable<ResponseDataOfRoleDetailsResponseModel> {
        let url_ = this.baseUrl + "/api/web/Roles/UpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfRoleDetailsResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfRoleDetailsResponseModel>;
        }));
    }

    protected processUpdateRole(response: HttpResponseBase): Observable<ResponseDataOfRoleDetailsResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfRoleDetailsResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRoleDetails(roleId: number): Observable<ResponseDataOfRoleDetailsResponseModel> {
        let url_ = this.baseUrl + "/api/web/Roles/GetRoleDetails?";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined and cannot be null.");
        else
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfRoleDetailsResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfRoleDetailsResponseModel>;
        }));
    }

    protected processGetRoleDetails(response: HttpResponseBase): Observable<ResponseDataOfRoleDetailsResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfRoleDetailsResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRoles(filterRequest: FilterRequest): Observable<ResponseDataOfPageListOfRoleResponseModel> {
        let url_ = this.baseUrl + "/api/web/Roles/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfPageListOfRoleResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfPageListOfRoleResponseModel>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ResponseDataOfPageListOfRoleResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDataOfPageListOfRoleResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ResponseDataOfFinanceTransactionResponseModel implements IResponseDataOfFinanceTransactionResponseModel {
    result?: FinanceTransactionResponseModel | undefined;
    error?: ResponseError | undefined;

    constructor(data?: IResponseDataOfFinanceTransactionResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? FinanceTransactionResponseModel.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ResponseError.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseDataOfFinanceTransactionResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseDataOfFinanceTransactionResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseDataOfFinanceTransactionResponseModel {
    result?: FinanceTransactionResponseModel | undefined;
    error?: ResponseError | undefined;
}

export class BaseAuditResponseModel implements IBaseAuditResponseModel {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date;
    lastModifiedBy?: string | undefined;

    constructor(data?: IBaseAuditResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
        }
    }

    static fromJS(data: any): BaseAuditResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new BaseAuditResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        return data;
    }
}

export interface IBaseAuditResponseModel {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date;
    lastModifiedBy?: string | undefined;
}

export class FinanceTransactionResponseModel extends BaseAuditResponseModel implements IFinanceTransactionResponseModel {
    id?: number;
    type?: EnumTransactionType;
    amount?: number;
    note?: string | undefined;
    categoryId?: number;
    category?: CategoryResponseModel | undefined;
    userId?: number;

    constructor(data?: IFinanceTransactionResponseModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.amount = _data["amount"];
            this.note = _data["note"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"] ? CategoryResponseModel.fromJS(_data["category"]) : <any>undefined;
            this.userId = _data["userId"];
        }
    }

    static override fromJS(data: any): FinanceTransactionResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new FinanceTransactionResponseModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["amount"] = this.amount;
        data["note"] = this.note;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        super.toJSON(data);
        return data;
    }
}

export interface IFinanceTransactionResponseModel extends IBaseAuditResponseModel {
    id?: number;
    type?: EnumTransactionType;
    amount?: number;
    note?: string | undefined;
    categoryId?: number;
    category?: CategoryResponseModel | undefined;
    userId?: number;
}

export enum EnumTransactionType {
    Income = 1,
    Expense = 2,
}

export class CategoryResponseModel extends BaseAuditResponseModel implements ICategoryResponseModel {
    name?: string;
    colour?: Colour;
    userId?: number;

    constructor(data?: ICategoryResponseModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.colour = _data["colour"] ? Colour.fromJS(_data["colour"]) : <any>undefined;
            this.userId = _data["userId"];
        }
    }

    static override fromJS(data: any): CategoryResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryResponseModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["colour"] = this.colour ? this.colour.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        super.toJSON(data);
        return data;
    }
}

export interface ICategoryResponseModel extends IBaseAuditResponseModel {
    name?: string;
    colour?: Colour;
    userId?: number;
}

export abstract class ValueObject implements IValueObject {

    constructor(data?: IValueObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ValueObject {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ValueObject' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IValueObject {
}

export class Colour extends ValueObject implements IColour {
    code?: string;

    constructor(data?: IColour) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.code = _data["code"];
        }
    }

    static override fromJS(data: any): Colour {
        data = typeof data === 'object' ? data : {};
        let result = new Colour();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        super.toJSON(data);
        return data;
    }
}

export interface IColour extends IValueObject {
    code?: string;
}

export class ResponseError implements IResponseError {
    statusCode?: number | undefined;
    message?: string | undefined;

    constructor(data?: IResponseError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ResponseError {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        return data;
    }
}

export interface IResponseError {
    statusCode?: number | undefined;
    message?: string | undefined;
}

export class FinanceTransactionRequestModel implements IFinanceTransactionRequestModel {
    id?: number | undefined;
    type?: EnumTransactionType;
    amount?: number;
    note?: string | undefined;
    categoryId?: number;

    constructor(data?: IFinanceTransactionRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.amount = _data["amount"];
            this.note = _data["note"];
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): FinanceTransactionRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new FinanceTransactionRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["amount"] = this.amount;
        data["note"] = this.note;
        data["categoryId"] = this.categoryId;
        return data;
    }
}

export interface IFinanceTransactionRequestModel {
    id?: number | undefined;
    type?: EnumTransactionType;
    amount?: number;
    note?: string | undefined;
    categoryId?: number;
}

export class ResponseDataOfBoolean implements IResponseDataOfBoolean {
    result?: boolean;
    error?: ResponseError | undefined;

    constructor(data?: IResponseDataOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            this.error = _data["error"] ? ResponseError.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseDataOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseDataOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseDataOfBoolean {
    result?: boolean;
    error?: ResponseError | undefined;
}

export class ResponseDataOfPageListOfFinanceMiniTransactionResponseModel implements IResponseDataOfPageListOfFinanceMiniTransactionResponseModel {
    result?: PageListOfFinanceMiniTransactionResponseModel | undefined;
    error?: ResponseError | undefined;

    constructor(data?: IResponseDataOfPageListOfFinanceMiniTransactionResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PageListOfFinanceMiniTransactionResponseModel.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ResponseError.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseDataOfPageListOfFinanceMiniTransactionResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseDataOfPageListOfFinanceMiniTransactionResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseDataOfPageListOfFinanceMiniTransactionResponseModel {
    result?: PageListOfFinanceMiniTransactionResponseModel | undefined;
    error?: ResponseError | undefined;
}

export class PageListOfFinanceMiniTransactionResponseModel implements IPageListOfFinanceMiniTransactionResponseModel {
    pageIndex?: number;
    pageSize?: number;
    total?: number;
    pageTotal?: number;
    filteredTotal?: number;
    items?: FinanceMiniTransactionResponseModel[];

    constructor(data?: IPageListOfFinanceMiniTransactionResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.total = _data["total"];
            this.pageTotal = _data["pageTotal"];
            this.filteredTotal = _data["filteredTotal"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FinanceMiniTransactionResponseModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageListOfFinanceMiniTransactionResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new PageListOfFinanceMiniTransactionResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["total"] = this.total;
        data["pageTotal"] = this.pageTotal;
        data["filteredTotal"] = this.filteredTotal;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPageListOfFinanceMiniTransactionResponseModel {
    pageIndex?: number;
    pageSize?: number;
    total?: number;
    pageTotal?: number;
    filteredTotal?: number;
    items?: FinanceMiniTransactionResponseModel[];
}

export class FinanceMiniTransactionResponseModel implements IFinanceMiniTransactionResponseModel {
    id?: number;
    type?: EnumTransactionType;
    amount?: number;
    categoryName?: string;
    created?: Date;
    lastModified?: Date;

    constructor(data?: IFinanceMiniTransactionResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.amount = _data["amount"];
            this.categoryName = _data["categoryName"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FinanceMiniTransactionResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new FinanceMiniTransactionResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["amount"] = this.amount;
        data["categoryName"] = this.categoryName;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        return data;
    }
}

export interface IFinanceMiniTransactionResponseModel {
    id?: number;
    type?: EnumTransactionType;
    amount?: number;
    categoryName?: string;
    created?: Date;
    lastModified?: Date;
}

export class FilterRequest implements IFilterRequest {
    pageIndex?: number;
    pageSize?: number;
    sort?: FilterSort[];
    filter?: FilterObject[];

    constructor(data?: IFilterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(FilterSort.fromJS(item));
            }
            if (Array.isArray(_data["filter"])) {
                this.filter = [] as any;
                for (let item of _data["filter"])
                    this.filter!.push(FilterObject.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FilterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        if (Array.isArray(this.filter)) {
            data["filter"] = [];
            for (let item of this.filter)
                data["filter"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFilterRequest {
    pageIndex?: number;
    pageSize?: number;
    sort?: FilterSort[];
    filter?: FilterObject[];
}

export abstract class FilterBaseOfZorroSortEnum implements IFilterBaseOfZorroSortEnum {
    key?: string;
    value?: ZorroSortEnum;

    constructor(data?: IFilterBaseOfZorroSortEnum) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): FilterBaseOfZorroSortEnum {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'FilterBaseOfZorroSortEnum' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IFilterBaseOfZorroSortEnum {
    key?: string;
    value?: ZorroSortEnum;
}

export class FilterSort extends FilterBaseOfZorroSortEnum implements IFilterSort {

    constructor(data?: IFilterSort) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): FilterSort {
        data = typeof data === 'object' ? data : {};
        let result = new FilterSort();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IFilterSort extends IFilterBaseOfZorroSortEnum {
}

export enum ZorroSortEnum {
    Asc = 0,
    Desc = 1,
}

export abstract class FilterBaseOfObject implements IFilterBaseOfObject {
    key?: string;
    value?: any | undefined;

    constructor(data?: IFilterBaseOfObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): FilterBaseOfObject {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'FilterBaseOfObject' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IFilterBaseOfObject {
    key?: string;
    value?: any | undefined;
}

export class FilterObject extends FilterBaseOfObject implements IFilterObject {

    constructor(data?: IFilterObject) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): FilterObject {
        data = typeof data === 'object' ? data : {};
        let result = new FilterObject();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IFilterObject extends IFilterBaseOfObject {
}

export class ResponseDataOfMonthlySummaryResponseModel implements IResponseDataOfMonthlySummaryResponseModel {
    result?: MonthlySummaryResponseModel | undefined;
    error?: ResponseError | undefined;

    constructor(data?: IResponseDataOfMonthlySummaryResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? MonthlySummaryResponseModel.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ResponseError.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseDataOfMonthlySummaryResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseDataOfMonthlySummaryResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseDataOfMonthlySummaryResponseModel {
    result?: MonthlySummaryResponseModel | undefined;
    error?: ResponseError | undefined;
}

export class MonthlySummaryResponseModel implements IMonthlySummaryResponseModel {
    totalIncome?: number;
    totalExpense?: number;
    balance?: number;

    constructor(data?: IMonthlySummaryResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalIncome = _data["totalIncome"];
            this.totalExpense = _data["totalExpense"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): MonthlySummaryResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new MonthlySummaryResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalIncome"] = this.totalIncome;
        data["totalExpense"] = this.totalExpense;
        data["balance"] = this.balance;
        return data;
    }
}

export interface IMonthlySummaryResponseModel {
    totalIncome?: number;
    totalExpense?: number;
    balance?: number;
}

export class ResponseDataOfListOfMonthlyTrendResponseModel implements IResponseDataOfListOfMonthlyTrendResponseModel {
    result?: MonthlyTrendResponseModel[] | undefined;
    error?: ResponseError | undefined;

    constructor(data?: IResponseDataOfListOfMonthlyTrendResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(MonthlyTrendResponseModel.fromJS(item));
            }
            this.error = _data["error"] ? ResponseError.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseDataOfListOfMonthlyTrendResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseDataOfListOfMonthlyTrendResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseDataOfListOfMonthlyTrendResponseModel {
    result?: MonthlyTrendResponseModel[] | undefined;
    error?: ResponseError | undefined;
}

export class MonthlyTrendResponseModel implements IMonthlyTrendResponseModel {
    month?: string;
    totalIncome?: number;
    totalExpense?: number;
    balance?: number;

    constructor(data?: IMonthlyTrendResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.totalIncome = _data["totalIncome"];
            this.totalExpense = _data["totalExpense"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): MonthlyTrendResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new MonthlyTrendResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["totalIncome"] = this.totalIncome;
        data["totalExpense"] = this.totalExpense;
        data["balance"] = this.balance;
        return data;
    }
}

export interface IMonthlyTrendResponseModel {
    month?: string;
    totalIncome?: number;
    totalExpense?: number;
    balance?: number;
}

export class ResponseDataOfCategoryResponseModel implements IResponseDataOfCategoryResponseModel {
    result?: CategoryResponseModel | undefined;
    error?: ResponseError | undefined;

    constructor(data?: IResponseDataOfCategoryResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? CategoryResponseModel.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ResponseError.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseDataOfCategoryResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseDataOfCategoryResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseDataOfCategoryResponseModel {
    result?: CategoryResponseModel | undefined;
    error?: ResponseError | undefined;
}

export class CategoryRequestModel implements ICategoryRequestModel {
    id?: number | undefined;
    name?: string;
    colorCode?: string;

    constructor(data?: ICategoryRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.colorCode = _data["colorCode"];
        }
    }

    static fromJS(data: any): CategoryRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["colorCode"] = this.colorCode;
        return data;
    }
}

export interface ICategoryRequestModel {
    id?: number | undefined;
    name?: string;
    colorCode?: string;
}

export class ResponseDataOfPageListOfCategoryResponseModel implements IResponseDataOfPageListOfCategoryResponseModel {
    result?: PageListOfCategoryResponseModel | undefined;
    error?: ResponseError | undefined;

    constructor(data?: IResponseDataOfPageListOfCategoryResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PageListOfCategoryResponseModel.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ResponseError.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseDataOfPageListOfCategoryResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseDataOfPageListOfCategoryResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseDataOfPageListOfCategoryResponseModel {
    result?: PageListOfCategoryResponseModel | undefined;
    error?: ResponseError | undefined;
}

export class PageListOfCategoryResponseModel implements IPageListOfCategoryResponseModel {
    pageIndex?: number;
    pageSize?: number;
    total?: number;
    pageTotal?: number;
    filteredTotal?: number;
    items?: CategoryResponseModel[];

    constructor(data?: IPageListOfCategoryResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.total = _data["total"];
            this.pageTotal = _data["pageTotal"];
            this.filteredTotal = _data["filteredTotal"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CategoryResponseModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageListOfCategoryResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new PageListOfCategoryResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["total"] = this.total;
        data["pageTotal"] = this.pageTotal;
        data["filteredTotal"] = this.filteredTotal;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPageListOfCategoryResponseModel {
    pageIndex?: number;
    pageSize?: number;
    total?: number;
    pageTotal?: number;
    filteredTotal?: number;
    items?: CategoryResponseModel[];
}

export class ResponseDataOfListOfTopCategoryExpenseResponseModel implements IResponseDataOfListOfTopCategoryExpenseResponseModel {
    result?: TopCategoryExpenseResponseModel[] | undefined;
    error?: ResponseError | undefined;

    constructor(data?: IResponseDataOfListOfTopCategoryExpenseResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(TopCategoryExpenseResponseModel.fromJS(item));
            }
            this.error = _data["error"] ? ResponseError.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseDataOfListOfTopCategoryExpenseResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseDataOfListOfTopCategoryExpenseResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseDataOfListOfTopCategoryExpenseResponseModel {
    result?: TopCategoryExpenseResponseModel[] | undefined;
    error?: ResponseError | undefined;
}

export class TopCategoryExpenseResponseModel implements ITopCategoryExpenseResponseModel {
    colour?: Colour;
    categoryName?: string;
    totalExpense?: number;

    constructor(data?: ITopCategoryExpenseResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.colour = _data["colour"] ? Colour.fromJS(_data["colour"]) : <any>undefined;
            this.categoryName = _data["categoryName"];
            this.totalExpense = _data["totalExpense"];
        }
    }

    static fromJS(data: any): TopCategoryExpenseResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new TopCategoryExpenseResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["colour"] = this.colour ? this.colour.toJSON() : <any>undefined;
        data["categoryName"] = this.categoryName;
        data["totalExpense"] = this.totalExpense;
        return data;
    }
}

export interface ITopCategoryExpenseResponseModel {
    colour?: Colour;
    categoryName?: string;
    totalExpense?: number;
}

export class ResponseDataOfTokenResponseModel implements IResponseDataOfTokenResponseModel {
    result?: TokenResponseModel | undefined;
    error?: ResponseError | undefined;

    constructor(data?: IResponseDataOfTokenResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? TokenResponseModel.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ResponseError.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseDataOfTokenResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseDataOfTokenResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseDataOfTokenResponseModel {
    result?: TokenResponseModel | undefined;
    error?: ResponseError | undefined;
}

export class TokenResponseModel implements ITokenResponseModel {
    accessToken?: string;
    refreshToken?: string;
    accessTokenExpiration?: Date;
    refreshTokenExpiration?: Date;

    constructor(data?: ITokenResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.accessTokenExpiration = _data["accessTokenExpiration"] ? new Date(_data["accessTokenExpiration"].toString()) : <any>undefined;
            this.refreshTokenExpiration = _data["refreshTokenExpiration"] ? new Date(_data["refreshTokenExpiration"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TokenResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new TokenResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["accessTokenExpiration"] = this.accessTokenExpiration ? this.accessTokenExpiration.toISOString() : <any>undefined;
        data["refreshTokenExpiration"] = this.refreshTokenExpiration ? this.refreshTokenExpiration.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITokenResponseModel {
    accessToken?: string;
    refreshToken?: string;
    accessTokenExpiration?: Date;
    refreshTokenExpiration?: Date;
}

export class LoginRequestModel implements ILoginRequestModel {
    userName?: string;
    password?: string;
    deviceId?: string | undefined;

    constructor(data?: ILoginRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.deviceId = _data["deviceId"];
        }
    }

    static fromJS(data: any): LoginRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["deviceId"] = this.deviceId;
        return data;
    }
}

export interface ILoginRequestModel {
    userName?: string;
    password?: string;
    deviceId?: string | undefined;
}

export class RegisterUserRequestModel implements IRegisterUserRequestModel {
    firstName?: string;
    lastName?: string;
    userName?: string;
    password?: string;

    constructor(data?: IRegisterUserRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterUserRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterUserRequestModel {
    firstName?: string;
    lastName?: string;
    userName?: string;
    password?: string;
}

export class ResponseDataOfPageListOfUserResponseModel implements IResponseDataOfPageListOfUserResponseModel {
    result?: PageListOfUserResponseModel | undefined;
    error?: ResponseError | undefined;

    constructor(data?: IResponseDataOfPageListOfUserResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PageListOfUserResponseModel.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ResponseError.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseDataOfPageListOfUserResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseDataOfPageListOfUserResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseDataOfPageListOfUserResponseModel {
    result?: PageListOfUserResponseModel | undefined;
    error?: ResponseError | undefined;
}

export class PageListOfUserResponseModel implements IPageListOfUserResponseModel {
    pageIndex?: number;
    pageSize?: number;
    total?: number;
    pageTotal?: number;
    filteredTotal?: number;
    items?: UserResponseModel[];

    constructor(data?: IPageListOfUserResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.total = _data["total"];
            this.pageTotal = _data["pageTotal"];
            this.filteredTotal = _data["filteredTotal"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserResponseModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageListOfUserResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new PageListOfUserResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["total"] = this.total;
        data["pageTotal"] = this.pageTotal;
        data["filteredTotal"] = this.filteredTotal;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPageListOfUserResponseModel {
    pageIndex?: number;
    pageSize?: number;
    total?: number;
    pageTotal?: number;
    filteredTotal?: number;
    items?: UserResponseModel[];
}

export class UserResponseModel implements IUserResponseModel {
    id?: number;
    firstName?: string;
    lastName?: string;
    userName?: string;
    isActive?: boolean;
    lastLogin?: Date;
    failedLoginAttempts?: number;
    roleId?: number;

    constructor(data?: IUserResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.isActive = _data["isActive"];
            this.lastLogin = _data["lastLogin"] ? new Date(_data["lastLogin"].toString()) : <any>undefined;
            this.failedLoginAttempts = _data["failedLoginAttempts"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): UserResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["isActive"] = this.isActive;
        data["lastLogin"] = this.lastLogin ? this.lastLogin.toISOString() : <any>undefined;
        data["failedLoginAttempts"] = this.failedLoginAttempts;
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface IUserResponseModel {
    id?: number;
    firstName?: string;
    lastName?: string;
    userName?: string;
    isActive?: boolean;
    lastLogin?: Date;
    failedLoginAttempts?: number;
    roleId?: number;
}

export class ResponseDataOfRoleDetailsResponseModel implements IResponseDataOfRoleDetailsResponseModel {
    result?: RoleDetailsResponseModel | undefined;
    error?: ResponseError | undefined;

    constructor(data?: IResponseDataOfRoleDetailsResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? RoleDetailsResponseModel.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ResponseError.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseDataOfRoleDetailsResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseDataOfRoleDetailsResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseDataOfRoleDetailsResponseModel {
    result?: RoleDetailsResponseModel | undefined;
    error?: ResponseError | undefined;
}

export class RoleDetailsResponseModel implements IRoleDetailsResponseModel {
    id?: number;
    name?: string;
    permissions?: string[];

    constructor(data?: IRoleDetailsResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): RoleDetailsResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDetailsResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data;
    }
}

export interface IRoleDetailsResponseModel {
    id?: number;
    name?: string;
    permissions?: string[];
}

export class RoleRequestModel implements IRoleRequestModel {
    id?: number;
    name?: string;
    permissions?: EnumPermission[];

    constructor(data?: IRoleRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): RoleRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new RoleRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data;
    }
}

export interface IRoleRequestModel {
    id?: number;
    name?: string;
    permissions?: EnumPermission[];
}

export enum EnumPermission {
    CreateRole = 1,
    UpdateRole = 2,
    DeleteRole = 3,
    GetRole = 4,
    CreateUser = 5,
    UpdateUser = 6,
    DeleteUser = 7,
    GetUser = 8,
}

export class ResponseDataOfPageListOfRoleResponseModel implements IResponseDataOfPageListOfRoleResponseModel {
    result?: PageListOfRoleResponseModel | undefined;
    error?: ResponseError | undefined;

    constructor(data?: IResponseDataOfPageListOfRoleResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? PageListOfRoleResponseModel.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ResponseError.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseDataOfPageListOfRoleResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseDataOfPageListOfRoleResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseDataOfPageListOfRoleResponseModel {
    result?: PageListOfRoleResponseModel | undefined;
    error?: ResponseError | undefined;
}

export class PageListOfRoleResponseModel implements IPageListOfRoleResponseModel {
    pageIndex?: number;
    pageSize?: number;
    total?: number;
    pageTotal?: number;
    filteredTotal?: number;
    items?: RoleResponseModel[];

    constructor(data?: IPageListOfRoleResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.total = _data["total"];
            this.pageTotal = _data["pageTotal"];
            this.filteredTotal = _data["filteredTotal"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleResponseModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageListOfRoleResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new PageListOfRoleResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["total"] = this.total;
        data["pageTotal"] = this.pageTotal;
        data["filteredTotal"] = this.filteredTotal;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPageListOfRoleResponseModel {
    pageIndex?: number;
    pageSize?: number;
    total?: number;
    pageTotal?: number;
    filteredTotal?: number;
    items?: RoleResponseModel[];
}

export class RoleResponseModel implements IRoleResponseModel {
    id?: number;
    name?: string;

    constructor(data?: IRoleResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RoleResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new RoleResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IRoleResponseModel {
    id?: number;
    name?: string;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}